\chapter{Метод грамматической эволюции в задаче синтеза системы управления} \label{chapter:ge}

Грамматическая эволюция (ГЭ) -- это эволюционный метод поиска символьных выражений (символьной регрессии).
ГЭ появилась как обобщение классического генетического программирования на класс формальных языков.

Для работы любого эволюционного метода необходимо выбрать параметры алгоритма -- так называемые метапараметры.
Метапараметры можно разделить на качественные (те, что задают структуру алгоритма поиска решения) и количественные (те, что определяют размерности матриц, мощности множеств и т.\,п.).

Выбор конкретных качественных метапараметров определяет метод из множества эволюционных методов. 
К качественным метапараметрам относятся:
\begin{enumerate}
    \item форма представления возможного решения задачи;
    \item алгоритм декодирования возможного решения;
    \item алгоритм поиска на множестве возможных решений.
\end{enumerate}

Любой из методов символьной регрессии в первую очередь определяется алгоритмом декодирования.
Алгоритм декодирования последовательно сопоставляет элементы представления возможного решения и элементы некоторого множества символьных выражений.
Правила сопоставления задают метод трансляции.
В результате работы алгоритма декодирования формируется символьное выражение.
Иногда алгоритм декодирования не требуется.
Например, в методе генетического программирования в качестве представления возможного решения задачи используются S-выражения вида~\eqref{intro:s_expression}, которые можно передавать в исходной форме в интерпретатор языка LISP.

В грамматической эволюции решения представлены в виде векторов, содержащих либо двоичные либо десятичные целочисленные значения.
В первом случае вектор перед декодированием преобразуется в десятичный путем разбиения вектора на непересекающиеся подпоследовательности фиксированной длины, каждая из которых трансформируется в десятичное целое число.

Алгоритм декодирования возможного решения в грамматической эволюции использует заранее созданную экспертом базу правил.
Она задается в форме Бэкуса--Наура~\cite{Backus1959} и описывает контекстно-свободную формальную грамматику.
Формальная грамматика определяет выражения некоторого языка.
Этот язык может быть подмножеством существующего, а может быть создан специально для решения определенной задачи -- так называемый предметно-ориентированный язык.
В последнем случае требуется создание транслятора.

Наконец, в качестве поискового алгоритма обычно используется генетический алгоритм~\cite{Ryan1998}, хотя возможны и другие варианты, например, дифференциальная эволюция~\cite{ONeill2006} или алгоритм роя частиц~\cite{ONeill2006a}.

Как следствие вышеизложенного, грамматическая эволюция -- модульный алгоритм.
Грамматика, алгоритм поиска и алгоритм вычисления целевой функции могут быть при необходимости заменены на другие.

Рассмотрим вначале составляющие грамматической эволюции.

\section{Представление структур} \label{sect:representation}

Грамматическая эволюция работает с множеством решений, то есть является популяционным алгоритмом.
Каждое решение представляет собой закодированное символьное выражение (или упорядоченное множество выражений) на некотором заранее заданном формальном языке.
Формальным языком называется множество конечных выражений над заданным конечным алфавитом.
В грамматической эволюции формальный язык задается контекстно-свободной формальной грамматикой.
Процесс отображения закодированных решений в символьные выражения использует базу правил в форме Бэкуса--Наура.

Грамматическая эволюция осуществляет поиск на множестве кодов конечных синтаксически корректных символьных выражений, принадлежащих заданному в форме Бэкуса--Наура формальному языку.

\subsection{Кодированное представление символьного выражения} \label{subsect:code}

В грамматической эволюции возможные решения представлены в виде битовых строк -- векторов вида

\begin{equation}
    \begin{array}{lcl}
        \mathbf{c}_i & = & \left[c^i_0, c^i_1, \dots, c^i_{n-1}\right]^T, \\
        c^i_k & \in & \left\{0; 1 \right\},
    \end{array}
    \label{ge:eq:chrom}
\end{equation}

В классическом варианте~\cite{ONeill2003} грамматической эволюции длина возможного решения жестко не задана, то есть количество элементов $n_j$ решения $\mathbf{c}_j$ не обязательно будет равно количеству элементов $n_i$ вектора $\mathbf{c}_i$.
Однако авторы алгоритма не обосновывают причины введения именно вариативной длины битовой строки.
Исследования, проведённые автором данной работы, показывают, что вариант алгоритма с фиксированной длиной вектора кодов решений также способен находить символьные решения поставленной задачи~\cite{DivKazSof2013}.

Каждое возможное решение перед формированием символьного выражения вначале преобразуется в вектор десятичных значений.
Для этого из вектора $\textbf{c}_i$ формируется упорядоченное множество двоичных чисел, каждое из которых преобразуется в десятичное следующим образом:
\begin{align}
    \begin{split}
        (c_0 c_1 \dots c_{k-1})_2 & = d^{(0)}_{10}, \\
        (c_{k} c_{k+1} \dots c_{2k-1})_2 & = d^{(1)}_{10}, \\
        \dots & \dots \\
        (c_{n_i-k} c_{n_i-k+1} \dots c_{n_i-1})_2 & = d^{(\left\lfloor{\frac{n_i}{k}}\right\rfloor-1)}_{10}.
    \end{split}
    \label{ge:eq:bin2dec}
\end{align}
В~\eqref{ge:eq:bin2dec} последовательность элементов вектора $\textbf{c}_i$ означает конкатенацию этих элементов, а нижний индекс -- систему счисления. 
Число разрядов двоичного числа $k$ выбирается проектировщиком алгоритма. 
В~\cite{ONeill2003} $k = 8$.
Таким образом формируется десятичный вектор кодов.
\begin{equation}
    \mathbf{d}_i = \left[\begin{array}{cccc} d_0 & d_1 & \dots & d_{m_i-1} \end{array}\right]^T.
    \label{ge:eq:dec_vec}
\end{equation}

Некоторые версии грамматической эволюции вместо двоичного представления сразу используют десятичный вектор~\eqref{ge:eq:dec_vec}.
Это упрощает процесс кодирования/декодирования, однако уменьшает вариативность исходов при применении операторов над парой кодов.

Так как $n_i$ меняется от решения к решению, то может возникнуть ситуация, когда в $n_i \mod k \neq 0$.
В этом случае большинство алгоритмов не учитывает часть вектора кодов, начинающуюся с $c_{n_i-k}$.


\subsection{Грамматика в грамматической эволюции} \label{subsect:rules}

Основной отличительной особенностью грамматической эволюции в классе методов генетического программирования является применение для вывода символьного выражения, корректного для некоторой контекстно-свободной формальной грамматики, заданной в форме Бэкуса--Наура (БНФ-грамматики). 
БНФ-грамматика, как правило, задается разработчиком и соответствует проблемной области, в которой ведётся поиск.
Зачастую БНФ-грамматика описывает подмножество выражений существующего языка программирования, ограничивая тем самым область поиска.

Для дальнейшего обсуждения использования БНФ-грамматики в грамматической эволюции необходимо ввести несколько определений.
Определим вначале понятие грамматики.

\begin{definition}
    Грамматикой называется кортеж $G = \left(N, T, S, P\right)$, где~\cite{JiaLiRaRe1998}:
    \begin{enumerate}
        \item $N$ -- конечное непустое множество нетерминальных символов (нетерминалов);
        \item $T$ -- конечное непустое множество терминальных символов (терминалов);
        \item $S \in V$ -- определенный нетерминал, называемый начальным символом;
        \item $P$ -- конечное непустое множество продукционных правил, имеющих вид
        \begin{equation*}
            \alpha \to \beta,
        \end{equation*}
        где $\alpha$ -- строка символов, включающая как минимум один нетерминальный символ, $\beta$ -- строка символов, содержащая как минимум один символ из множества $N \cup T$.
    \end{enumerate}
    \label{ge:def:grammar}
\end{definition}

\begin{definition}
    Контекстно-свободной формальной грамматикой называется такая грамматика, у которой во множестве $P$ продукционных правил все продукционные правила в левой части содержат ровно один нетерминальный символ~\cite{JiaLiRaRe1998}: $\alpha \in N$.
    \label{ge:def:cffg}
\end{definition}

\begin{definition}
    Нетерминальным символом называется символ, который может быть заменен на другие символы.
\end{definition}

\begin{definition}
    Терминальным символом называется символ, который не может быть заменен на другие символы.
\end{definition}

Множества терминальных символов $T$ и нетерминальных символов $N$ не пересекаются:
\begin{equation}
    T \cap N = \emptyset.
\end{equation}

Продукционные правила для контекстно-свободной формальной грамматики могут быть заданы задаются в следующем виде:
\begin{equation}
    \mathrm{nonterminal} ::= \mathrm{expression\_1}\ \vert\ \mathrm{expression\_2}\ \vert\ \dots,
    \label{ge:eq:prod_rule}
\end{equation}
где \texttt{nonterminal} -- нетерминальный символ, подлежащий замене, $\vert$ -- символ, разделяющий варианты замены нетерминальных символов.
Выражения \texttt{expression\_n} могут содержать как терминальные, так и нетерминальные символы.

Продукционные правила применяются к символьной строке до тех пор, пока в строке не останутся исключительно терминальные символы.

\begin{example}
    Рассмотрим простейший пример продукционного правила.
    Пусть $N = \left\{a \right\}$, $T = \left\{ A \right\} $.
    Тогда можно, к примеру, задать следующее продукционное правило:

    \begin{equation*}
        a ::= aA\ \vert\ A.
    \end{equation*}

    Если следовать данному продукционному правилу для начальной строки, состоящей из нетерминального символа $\mathrm{a}$, то можно формировать строки символов длины не менее 1, состоящие из терминальных символов $A$.
\end{example}

База правил использует вектор целых чисел (см.~\ref{subsect:code}) формирования символьного выражения.

\subsection{Множество решений} \label{subsect:population}

12345

\subsection{Представление решения} \label{subsect:representation}

12345

\section{Поисковый алгоритм} \label{sect:engine}

Исследования показывают, что стационарный генетический алгоритм~\cite{DeJoSarm1992} демонстрирует в грамматической эволюции хорошую производительность~\cite{RyanONe1998}.

\subsection{Алгоритмы отбора} \label{subsect:selection}

\subsection{Операторы модификации кодов решений} \label{subsect:modifications}

Основными в классе эволюционных алгоритмов являются два класса операторов: операторы над парой кодов возможных решений и операторы над одним кодом возможных решений.
Операторы обоих классов вероятностные.
Операторы над парой кодов в терминологии генетических алгоритмов называются <<операторами скрещивания>>.

Пусть $V$ -- множество всех кодов возможных решений.

\begin{definition}
    Оператором над парой кодов будем называть оператор $\Xi: V \times V \to V \times V$.
\end{definition}

Дадим формальное описание нескольких операторов преобразования решений.

Для упрощения последующих выводов положим, что код $i$-го решения является вектором $\mathbf{c}_i = \left[c^i_0, c^i_1, \dots, c^i_{n-1}\right]^T$, причем $c^i_k \in \left\{0; 1 \right\}$, $\mathbf{c}_i \in V$.

Пусть $P(k)$ -- вероятность выбора $k$-го элемента из множества индексов $Z = \left\{x~|~x \in \mathbf{Z}, x \in \left[0; n-1\right] \right\}$.

\begin{definition}
    Одноточечным оператором над парой кодов $\mathbf{c}_1, \mathbf{c}_2$ назовем такой оператор 
    $$A\left(\mathbf{c}_1, \mathbf{c}_2, k\right) = \mathrm{diag}\left\{a_0, a_1, \dots, a_k, a_{k+1}, \dots, a_{n-1}\right\},$$ что 
    $$a_i = \begin{cases} 1, & i \leq k \\ 0, & i > k \end{cases}.$$
\end{definition}


\begin{equation}
    \begin{array}{ccc}
        c_3 & = & A c_1 + (I - A) c_2  \\
        c_4 & = & A c_2 + (I - A) c_1  
    \end{array}
\end{equation}

Влияние типа скрещивания на скорость сходимости ГЭ велико, так как процесс декодирования хромосомы в символьное выражение производится в порядке расположения генов в векторе.
Чтобы обосновать это утверждение, введем два определения.

\begin{definition}
    Голова хромосомы $C~=~\left[c_0, c_1, \dots , c_{n-1} \right]^T$ -- вектор генов $\left[c_0, c_1, ..., c_k \right]^T, 0~<~k~\leq~n-1$, влияющих на фенотип.
\end{definition}

\begin{definition}
    Хвост хромосомы $C~=~\left[c_0, c_1, \dots , c_{n-1} \right]^T$ -- вектор генов $\left[c_k, c_{k+1}, ..., c_{n-1} \right]^T, k~>~0$, не влияющих на фенотип.
\end{definition}

В классической версии ГЭ используется одноточечное скрещивание [???]. 
Этот тип скрещивания приводит к сравнительно более медленной эволюции. % Доказательство 
Причина в следующем (см. рис. ???): если точка скрещивания приходится на <<голову>> хромосомы, то происходит обмен активным генетическим материалом; если же точка скрещивания относится к хвостовой, неактивной части вектора, то полученные потомки фенотипически не отличаются.
Хвостовая часть хромосомы зачастую занимает большую часть вектора.
Таким образом, существенное количество скрещиваний не приводит к изменению популяции.
Влияние хвостового скрещивания на популяцию определяется использованным эволюционным методом, а, точнее, критерием эволюционного отбора. 

Примеры.

\clearpage
